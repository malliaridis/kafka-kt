/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.kafka.queue

import java.util.concurrent.RejectedExecutionException
import java.util.concurrent.TimeoutException
import java.util.function.Function
import org.slf4j.Logger

interface EventQueue : AutoCloseable {
    
    fun interface Event {
    
        /**
         * Run the event.
         */
        @Throws(Exception::class)
        fun run()

        /**
         * Handle an exception that was either generated by running the event, or by the event queue's inability
         * to run the event.
         *
         * @param exception The exception. This will be a [TimeoutException] if the event hit its deadline
         * before it could be scheduled. It will be a [RejectedExecutionException] if the event could not be
         * scheduled because the event queue has already been closed. Otherwise, it will be whatever exception
         * was thrown by [run].
         */
        fun handleException(exception: Throwable?) = Unit
    }

    /**
     * Add an element to the front of the queue.
     *
     * @param event The mandatory event to prepend.
     */
    fun prepend(event: Event) = enqueue(
        insertionType = EventInsertionType.PREPEND,
        tag = null,
        deadlineNsCalculator = NoDeadlineFunction.INSTANCE,
        event = event,
    )

    /**
     * Add an element to the end of the queue.
     *
     * @param event The event to append.
     */
    fun append(event: Event) = enqueue(
        insertionType = EventInsertionType.APPEND,
        tag = null,
        deadlineNsCalculator = NoDeadlineFunction.INSTANCE,
        event = event,
    )

    /**
     * Add an event to the end of the queue.
     *
     * @param deadlineNs The deadline for starting the event, in monotonic nanoseconds. If the event has not started
     * by this deadline, handleException is called with a [org.apache.kafka.common.errors.TimeoutException],
     * and the event is cancelled.
     * @param event The event to append.
     */
    fun appendWithDeadline(deadlineNs: Long, event: Event) = enqueue(
        insertionType = EventInsertionType.APPEND,
        tag = null,
        deadlineNsCalculator = DeadlineFunction(deadlineNs),
        event = event,
    )

    /**
     * Schedule an event to be run at a specific time.
     *
     * @param tag If this is non-null, the unique tag to use for this event. If an event with this tag
     * already exists, it will be cancelled.
     * @param deadlineNsCalculator A function which takes as an argument the existing deadline for the event
     * with this tag (or empty if the event has no tag, or if there is none such), and produces the deadline
     * to use for this event. Once the deadline has arrived, the event will be run. Events whose deadlines
     * are only a few nanoseconds apart may be executed in any order.
     *
     * @param event The event to schedule.
     */
    fun scheduleDeferred(
        tag: String?,
        deadlineNsCalculator: Function<Long?, Long?>,
        event: Event,
    ) = enqueue(
        insertionType = EventInsertionType.DEFERRED,
        tag = tag,
        deadlineNsCalculator = deadlineNsCalculator,
        event = event,
    )

    /**
     * Cancel a deferred event.
     *
     * @param tag The unique tag for the event to be cancelled. Must be non-null. If the event with the tag
     * has not been scheduled, this call will be ignored.
     */
    fun cancelDeferred(tag: String)

    enum class EventInsertionType {
        PREPEND,
        APPEND,
        DEFERRED
    }

    /**
     * Add an event to the queue.
     *
     * @param insertionType How to insert the event. `PREPEND` means insert the event as the first thing
     * to run. `APPEND` means insert the event as the last thing to run. `DEFERRED` means insert the event to
     * run after a delay.
     * @param tag If this is non-null, the unique tag to use for this event. If an event with this tag already
     * exists, it will be cancelled.
     * @param deadlineNsCalculator If this is non-null, it is a function which takes as an argument
     * the existing deadline for the event with this tag (or null if the event has no tag, or if there is none such),
     * and produces the deadline to use for this event (or empty to use none). Events whose deadlines are only
     * a few nanoseconds apart may be executed in any order.
     * @param event The event to enqueue.
     */
    fun enqueue(
        insertionType: EventInsertionType,
        tag: String?,
        deadlineNsCalculator: Function<Long?, Long?>?,
        event: Event,
    )

    /**
     * Asynchronously shut down the event queue.
     *
     * No new events will be accepted, and the queue thread will exit after running the existing events.
     * Deferred events will receive TimeoutExceptions.
     *
     * @param source The source of the shutdown.
     */
    fun beginShutdown(source: String?)

    /**
     * @return The number of pending and running events. If this is 0, there is no running event and
     * no events queued.
     */
    fun size(): Int

    fun isEmpty(): Boolean = size() == 0

    fun isNotEmpty(): Boolean = size() != 0

    /**
     * This method is used during unit tests where MockTime is in use.
     * It is used to alert the queue that the mock time has changed.
     */
    fun wakeup() = Unit

    /**
     * Synchronously close the event queue and wait for any threads to be joined.
     */
    @Throws(InterruptedException::class)
    override fun close()

    abstract class FailureLoggingEvent(private val log: Logger) : Event {

        override fun handleException(exception: Throwable?) {
            if (exception is RejectedExecutionException)
                log.info("Not processing {} because the event queue is closed.", this)
            else log.error("Unexpected error handling {}", this, exception)
        }

        override fun toString(): String = this.javaClass.name
    }

    class NoDeadlineFunction : Function<Long?, Long?> {

        override fun apply(ignored: Long?): Long? = null

        companion object {
            val INSTANCE = NoDeadlineFunction()
        }
    }

    class DeadlineFunction(private val deadlineNs: Long) : Function<Long?, Long?> {

        override fun apply(ignored: Long?): Long = deadlineNs
    }

    class EarliestDeadlineFunction(private val newDeadlineNs: Long) : Function<Long?, Long?> {

        override fun apply(prevDeadlineNs: Long?): Long {
            return if (prevDeadlineNs == null) newDeadlineNs
            else if (prevDeadlineNs < newDeadlineNs) prevDeadlineNs
            else newDeadlineNs
        }
    }

    class VoidEvent : Event {

        @Throws(Exception::class)
        override fun run() = Unit

        companion object {
            val INSTANCE = VoidEvent()
        }
    }
}
