/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.kafka.common

import java.nio.ByteBuffer
import java.util.*

/**
 * This class defines an immutable universally unique identifier (UUID). It represents a 128-bit
 * value. More specifically, the random UUIDs generated by this class are variant 2 (Leach-Salz)
 * version 4 UUIDs. This is the same type of UUID as the ones generated by java.util.UUID. The
 * toString() method prints using the base64 string encoding. Likewise, the fromString method
 * expects a base64 string encoding.
 *
 * Constructor constructs a 128-bit type 4 UUID where the first long represents the most significant
 * 64 bits and the second long represents the least significant 64 bits.
 *
 * @property mostSignificantBits The most significant bits of the UUID's 128 value.
 * @property leastSignificantBits The least significant bits of the UUID's 128 value.
 */
data class Uuid(
    val mostSignificantBits: Long,
    val leastSignificantBits: Long
) : Comparable<Uuid?> {

    /**
     * Returns a base64 string encoding of the UUID.
     */
    override fun toString(): String {
        return Base64.getUrlEncoder()
            .withoutPadding()
            .encodeToString(bytesFromUuid)
    }

    private val bytesFromUuid: ByteArray
        get() {
            // Extract bytes for uuid which is 128 bits (or 16 bytes) long.
            val uuidBytes = ByteBuffer.wrap(ByteArray(UUID_SIZE))
            uuidBytes.putLong(mostSignificantBits)
            uuidBytes.putLong(leastSignificantBits)
            return uuidBytes.array()
        }

    override operator fun compareTo(other: Uuid?): Int {
        return if (other == null) 1
        else if (mostSignificantBits > other.mostSignificantBits) 1
        else if (mostSignificantBits < other.mostSignificantBits) -1
        else if (leastSignificantBits > other.leastSignificantBits) 1
        else if (leastSignificantBits < other.leastSignificantBits) -1
        else 0
    }

    companion object {

        /**
         * The UUID size in bytes.
         */
        private const val UUID_SIZE = 16

        /**
         * A UUID for the metadata topic in KRaft mode. Will never be returned by the randomUuid
         * method.
         */
        val METADATA_TOPIC_ID = Uuid(0L, 1L)

        /**
         * A UUID that represents a null or empty UUID. Will never be returned by the randomUuid
         * method.
         */
        val ZERO_UUID = Uuid(0L, 0L)

        private fun unsafeRandomUuid(): Uuid {
            val jUuid = UUID.randomUUID()
            return Uuid(jUuid.mostSignificantBits, jUuid.leastSignificantBits)
        }

        /**
         * Static factory to retrieve a type 4 (pseudo randomly generated) UUID.
         *
         * This will not generate a UUID equal to 0, 1, or one whose string representation starts
         * with a dash ("-")
         */
        fun randomUuid(): Uuid {
            var uuid = unsafeRandomUuid()
            while (uuid == METADATA_TOPIC_ID || uuid == ZERO_UUID || uuid.toString()
                    .startsWith("-")
            ) {
                uuid = unsafeRandomUuid()
            }
            return uuid
        }

        /**
         * Creates a UUID based on a base64 string encoding used in the toString() method.
         */
        fun fromString(str: String): Uuid {
            if (str.length > 24) {
                throw IllegalArgumentException(
                    "Input string with prefix `${str.substring(0, 24)}`" +
                            " is too long to be decoded as a base64 UUID"
                )
            }
            val uuidBytes = ByteBuffer.wrap(Base64.getUrlDecoder().decode(str))
            if (uuidBytes.remaining() != 16) {
                throw IllegalArgumentException(
                    "Input string `$str` decoded as ${uuidBytes.remaining()}" +
                            " bytes, which is not equal to the expected 16 bytes" +
                            " of a base64-encoded UUID"
                )
            }
            return Uuid(uuidBytes.getLong(), uuidBytes.getLong())
        }
    }
}
